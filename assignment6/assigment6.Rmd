---
title: "PoCS Assignment 5"
author: "P. Alexander Burnham"
date: "October 8, 2018"
output: pdf_document
---
PoCS Assignment github repo: https://github.com/alexburn17/BurnhamPoCS


Worked with: Yu Han, Edison & Kewang


**Problem 1:**

**a)**


**Problem 2:**

**Problem 3:**



**a)**


```{r, echo=FALSE, message=FALSE}
#library(igraph)
#library(raster)

# params
p <- seq(0, 1, length.out = 100)
N <- 100

# BEGIN FUNCTION ########################################################
forest <- function(N=N, p=p, L=L, frac=frac){
  for(j in 1:N){
    for(i in 1:length(p)){

      # random data (1=tree or 0=sheep)
      dat <- sample(0:1, L*L, replace=T, prob = c(p[i], (1-p[i])))
      mat <- matrix(nrow = L, ncol = L, data = dat)

      # calculate fraction 
      Rmat <- raster(mat)
      frac[i,j] <- (max(as.matrix(clump(Rmat, directions=4)), na.rm=T))/L^2
    }
  }
  return(frac)
}
# END FUNCTION ###########################################################


# Start Program Body #####################################################

#### L=20
# prealocate matrix space
#frac <- matrix(ncol = N, nrow = length(p))
# run function
#v20 <- forest(N=N, p=p, L=20, frac=frac)
# creat vecotr of means
#v20vec <- rowMeans(v20, na.rm=T)


#### L=50
# prealocate matrix space
#frac1 <- matrix(ncol = N, nrow = length(p))
# run function
#v50 <- forest(N=N, p=p, L=50, frac=frac1)
# creat vecotr of means
#v50vec <- rowMeans(v50, na.rm=T)


#### L=100
# prealocate matrix space
#frac2 <- matrix(ncol = N, nrow = length(p))
# run function
#v100 <- forest(N=N, p=p, L=100, frac=frac2)
# creat vecotr of means
#v100vec <- rowMeans(v100, na.rm=T)


#### L=200
# prealocate matrix space
#frac3 <- matrix(ncol = N, nrow = length(p))
# run function
#v200 <- forest(N=N, p=p, L=200, frac=frac3)
# creat vecotr of means
#v200vec <- rowMeans(v200, na.rm=T)


#problem3DF <- data.frame(p, v20vec, v50vec, v100vec, v200vec)
#write.csv(problem3DF, "problem3DF.csv")


setwd("~/Documents/GitHub/BurnhamPoCS/assignment6")
problem3DF <- read.csv("problem3DF.csv", header=TRUE, stringsAsFactors=FALSE)



colors <- c("green", "red", "blue", "black")

matplot(y=problem3DF[,2:5], x=p, type = "l", xlab = "p",
        ylab = "S_avg", lwd=3, 
        col=colors, ylim = c(0, .2), 
        lty=1, cex.lab = 1.3, 
        main="S_avg as a function of p for varying L")

grid()

legend(0.01, 0.2, 
       legend=c("L=20", "L=50", "L=100" ,"L=200"), 
       col=colors, lty=1, cex=.8)
abline(h=0.130231)
abline(v=0.717172)
text("p_c = 0.717172", x=0.87, y=.19)



#image(mat, asp=1, xaxt='n', yaxt='n', col = c("black", "grey"), ann=FALSE, bty='n')
#legend(x=-.35, y=1, legend=c("Tree", "Sheep"), col = c("black", "grey"), pch=15, cex=1)

```

**b)**

As L increases, the accuracy (lack of stochasticity or variance) increases. The curve tends to smooth out and the values for S_avg_ tend to be lower. The estimate for p_c_ is 0.7172 which is the maximum point on the most accurate curve (L=200).



**Problem 4:**


**Problem 5:**



**a)**



```{r, echo=FALSE, message=FALSE}

library("poweRlaw")

N=c(1, 10^2, 10^3, 10^4, 10^5, 10^6) 
k=(1:1000)


mat <- matrix(nrow = 1000, ncol = 6)

for(n in 1:6){
  for(i in 1:1000){
    mat[i, n] <- max(rpldis(n=N[n], xmin=1, alpha=3/2, discrete_max = 1000))
}
}


matDat <- as.data.frame(mat)
CD.sorted <- apply(matDat, 2, sort, decreasing=T)

setwd("~/Documents/GitHub/BurnhamPoCS/assignment4")

# Read in Data:
mat <- read.csv("NKsorted.csv", 
                header=TRUE, 
                stringsAsFactors = FALSE)

mat2 <- as.matrix(mat)

matplot(log10(mat2), type="o", cex=.2, main="K_max by N", xlab = "Rank", ylab="log10(k_max)", col=c(1:6))
legend("topright", inset=0.01, legend=c("10^1","10^2","10^3","10^4","10^5","10^6"), col=c(1:6), pch=15)

```



**b)**



```{r, echo=FALSE, message=FALSE}
par(mfrow=c(1,2))

kmeanEst <- colMeans(mat2)
mod5 <- lm(log10(kmeanEst)~log10(N)) 
plot(y=log10(kmeanEst), x=log10(N), main="K_max estimate by N", xlab = "log10(N)", ylab = "log10((k_max))")
abline(mod5, col="blue")
text(x=2,y=4, "slope = 0.6262")

gamma <- 3/2

kmeanTher <- ((gamma-1)/(gamma-2))*N^((2-gamma)/(gamma-1))

mod6 <- lm(log10(kmeanTher)~log10(N)) 
plot(y=log10(kmeanTher), x=log10(N), main="K_max theoretical by N", xlab = "log10(N)", ylab = "log10((k_max))")
abline(mod6, col="red")
text(x=3,y=.3, "slope = -0.3333")
par(mfrow=c(1,1))
```

My theoretical value and empirical values do no match up. The one I calculated by sampling a powerlaw distribution has a positive slope of around 0.6. This makes sense as the max k should increase as the sample size increases. However, my derivation of the theoretical max k has a negative slope of -0.3. This does no make sense and leads me to believe that my model is correct and the theoretical values are incorrect. $K_max$ should increase as N increases as this increase in N gives higher probability of capturing a large $K$. The theretical value looks like it is flipped about the y axis as the spacing of the points is simaler.

